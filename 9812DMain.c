#pragma config(Sensor, in3,    armpot,         sensorPotentiometer)
#pragma config(Sensor, dgtl8,  slidingtouch,   sensorTouch)
#pragma config(Sensor, dgtl9,  doubletouch,    sensorTouch)
#pragma config(Sensor, dgtl10, encoder,        sensorRotation)
#pragma config(Motor,  port1,           left,          tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port7,           Hook,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           openclose,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           arm,           tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          right,         tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX2)
#pragma competitionControl(Competition)
#include "Vex_Competition_Includes.c"
void pre_auton()
{
	bStopTasksBetweenModes = true;
}
//do not mess with anthing above this!
/*ok i wont!*/
void encoderforwards (float howMany)
{
	SensorValue[encoder] = 0;
	while(SensorValue[encoder] < howMany*90)
	{
		//...Move Forward
		motor[right] = 127;
		motor[left] = 127;
	}
	motor[right] = 0;
	motor[left] = 0;

}

void encoderright (float howMany)
{
	SensorValue[encoder] = 0;
	while(SensorValue[encoder] < howMany*90)
	{
		//...Move Forward
		motor[right] = -127;
		motor[left] = 127;
	}
	motor[right] = 0;
	motor[left] = 0;

}
void encoderleft (float howMany)
{
	SensorValue[encoder] = 0;
	while(SensorValue[encoder] < howMany*90)
	{
		//...Move Forward
		motor[right] = 127;
		motor[left] = -127;
	}
	motor[right] = 0;
	motor[left] = 0;

}
void encoderbackward (float howMany)
{
	SensorValue[encoder] = 0;
	while(SensorValue[encoder] < howMany*90)
	{
		//...Move Backwards
		motor[right] = -127;
		motor[left] = -127;
	}
	motor[right] = 0;
	motor[left] = 0;

}

void raisetolift ()
{
	while(SensorValue[armpot] < 210)
	{
		//...Move Backwards
		motor[arm] = 127;
	}
	motor[arm] = 0;

}
void lowertolift ()
{
	while(SensorValue[armpot] > 78)
	{
		//...Move Backwards
		motor[arm] = -127;
	}
	motor[arm] = 0;
}

void slidetouch ()
{
	while (SensorValue(slidingtouch) ==0)
	{
		motor[openclose] = 127;
	}
	// DON"T FORGET TO TURN THE MOTOR OFF HERE
}
//???????????????????????????
//WHAT IS THIS FUNCTION FOR? 
void unslidetouch (){
	while (SensorValue(slidingtouch) ==1)
	{
		motor[openclose] = 0;
	}
}
//??????????????????????????
void backwardtouch (){
	while (SensorValue(doubletouch) == 1/*I THINK YOU MEANT TO CHECK FOR 0 HERE*/)
	{
		motor[openclose] = 0;//I THINK YOU MEANT TO TURN THE MOTOR ON HERE
	}
	//DON'T FORGET TO TURN THE MOTOR OFF HERE
}
//****************************************autonomus****************************************
void doAutonomous()
{
	//go forward
  encoderforwards(3);
  //turn left
  encoderleft(2);
  //move forward
  encoderforwards(1);
  //move backwards
  encoderbackward(2);
  //pull arm up
  raisetolift();
  //pull itself up
  slidetouch();
  lowertolift();








}

task autonomous()
{
	doAutonomous();
}

//****************************************usercontrol***************************************
task usercontrol()
{
	while (true)
	{
		if(vexRT[Btn7L] == 1)
		{
			doAutonomous();
		}


		//joystick controls for driving
		motor[right] = vexRT[Ch2];
		motor[left] = vexRT[Ch3];

		//Buttons to move arm
		if(vexRT[Btn5UXmtr2]==1)
		{
			motor[arm] = 120;
		}
		else if(vexRT[Btn5DXmtr2]==1)
		{
			motor[arm] = -80;
		}
		else
		{
			motor[arm] = 0;
		}

		//Buttons to open / close claw
		if(vexRT[Btn6UXmtr2]==1)
		{
			motor[openclose] = 127;
		}
		else if(vexRT[Btn6DXmtr2]==1)
		{
			motor[openclose] = -127;
		}
		else
		{
			motor[openclose] = 0;
		}
		//Buttons to hook for hang hook
		if(vexRT[Btn7UXmtr2]==1)
		{
			motor[Hook] = -127;

			wait1Msec(0500);

			motor[Hook] = 0;
		}
    //Buttons to UNhook for hang hook
		if(vexRT[Btn7DXmtr2]==1)
	  {
	  	motor[Hook] = 127;

	  	wait1Msec(0500);

	  	motor[Hook] = 0;
	  }
	}



}
